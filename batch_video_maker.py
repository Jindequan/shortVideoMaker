#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Batch Video Maker Script

This script reads a list of viral video titles from a file and processes each one
to generate a complete video using the shortVideoMaker pipeline.
All configuration settings are read from the project's config.toml file.

Usage:
    python batch_video_maker.py --file titles.txt [options]

Options:
    --file TEXT                Path to file containing video titles (one per line)
    --max-titles INT           Maximum number of titles to process [default: all]
    --start-index INT          Start processing from this index [default: 0]
"""

import argparse
import json
import os
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional, Union

from loguru import logger

# Add the project root to the Python path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.config import config
from app.models.schema import VideoParams, VideoConcatMode, VideoAspect, VideoTransitionMode
from app.services import task as tm
from app.utils import utils


def setup_logger():
    """Configure the logger for the script."""
    logger.remove()
    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO",
    )
    log_file = utils.storage_dir("logs", create=True)
    logger.add(
        os.path.join(log_file, "batch_video_maker_{time}.log"),
        rotation="100 MB",
        level="DEBUG",
    )


def read_titles_from_file(file_path: str) -> List[str]:
    """Read video titles from a file, one title per line, ignoring empty lines."""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            # 读取所有行，去除空白字符，并过滤掉空行
            titles = [line.strip() for line in f.readlines()]
            titles = [title for title in titles if title]  # 忽略空行
        logger.info(f"Read {len(titles)} titles from file (ignoring empty lines)")
        return titles
    except Exception as e:
        logger.error(f"Failed to read titles from file: {e}")
        return []


def create_video_params(title: str) -> VideoParams:
    """Create VideoParams object for the given title using settings from config.toml."""
    # 从配置文件读取视频设置
    video_source = config.app.get("video_source", "pexels")

    # 从配置文件读取语音设置
    voice_name = config.ui.get("voice_name", "zh-CN-XiaoyiNeural-Female")
    voice_rate = float(config.ui.get("voice_rate", 1.2))

    # 从配置文件读取字幕设置
    subtitle_position = config.ui.get("subtitle_position", "bottom")
    custom_position = float(config.ui.get("custom_position", 70.0))
    font_name = config.ui.get("font_name", "STHeitiMedium.ttc")
    font_size = int(config.ui.get("font_size", 60))
    text_fore_color = config.ui.get("text_fore_color", "#FFFFFF")

    # 从配置文件读取视频格式设置
    video_aspect_str = config.ui.get("video_aspect", "9:16")
    video_aspect = VideoAspect.portrait.value
    if video_aspect_str == "16:9":
        video_aspect = VideoAspect.landscape.value
    elif video_aspect_str == "1:1":
        video_aspect = VideoAspect.square.value

    # 其他设置
    video_language = config.ui.get("video_language", "")
    paragraph_number = int(config.ui.get("paragraph_number", 1))
    video_count = int(config.ui.get("video_count", 1))

    logger.info(f"Using configuration from config.toml:")
    logger.info(f"  - Video source: {video_source}")
    logger.info(f"  - Voice: {voice_name} (rate: {voice_rate})")
    logger.info(f"  - Subtitle position: {subtitle_position} ({custom_position}% from top)")
    logger.info(f"  - Video aspect: {video_aspect}")

    return VideoParams(
        video_subject=title,
        video_script="",  # Will be generated by LLM
        video_aspect=video_aspect,
        video_source=video_source,
        voice_name=voice_name,
        voice_rate=voice_rate,
        video_language=video_language,
        paragraph_number=paragraph_number,
        video_count=video_count,
        video_concat_mode=VideoConcatMode.random.value,
        video_transition_mode=VideoTransitionMode.fade_in.value,
        video_clip_duration=5,
        n_threads=4,
        bgm_type="random",
        bgm_volume=0.2,
        # Subtitle positioning
        subtitle_enabled=True,
        subtitle_position=subtitle_position,
        custom_position=custom_position,
        # Font settings
        font_name=font_name,
        font_size=font_size,
        text_fore_color=text_fore_color,
    )


def process_title(
    title: str,
    index: int,
    total: int,
    params: VideoParams,
) -> Dict:
    """Process a single title to generate a video."""
    logger.info(f"[{index+1}/{total}] Processing title: {title}")

    # Generate a task ID
    task_id = utils.get_uuid()
    logger.info(f"Task ID: {task_id}")

    # Create task directory
    task_dir = utils.task_dir(task_id)

    # Save title information
    with open(os.path.join(task_dir, "title.txt"), "w", encoding="utf-8") as f:
        f.write(title)

    try:
        # Start the task
        result = tm.start(task_id=task_id, params=params, stop_at="video")

        if not result or "videos" not in result:
            logger.error(f"Failed to generate video for title: {title}")
            return {"success": False, "task_id": task_id, "title": title, "error": "Video generation failed"}

        # Generate catchy title and tags using LLM
        from app.services import llm

        prompt = f"""
        Based on the following video title and script, generate:
        1. A catchy, viral-worthy title (in the same language as the original)
        2. 5-10 relevant hashtags/tags for social media platforms

        Original Title: {title}
        Script: {result.get('script', '')}

        Format your response as a JSON object with two keys:
        - "catchy_title": "Your catchy title here"
        - "tags": ["tag1", "tag2", "tag3", ...]
        """

        metadata_response = llm._generate_response(prompt)
        try:
            metadata = json.loads(metadata_response)
            # Save metadata
            with open(os.path.join(task_dir, "metadata.json"), "w", encoding="utf-8") as f:
                json.dump(metadata, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.warning(f"Failed to parse metadata response: {e}")
            metadata = {"catchy_title": title, "tags": []}

        # Save result information
        with open(os.path.join(task_dir, "result.json"), "w", encoding="utf-8") as f:
            # Add metadata to result
            result_with_metadata = {**result, "metadata": metadata}
            json.dump(result_with_metadata, f, ensure_ascii=False, indent=2)

        logger.success(f"Successfully generated video for title: {title}")
        logger.info(f"Catchy title: {metadata.get('catchy_title', title)}")
        logger.info(f"Tags: {', '.join(metadata.get('tags', []))}")
        logger.info(f"Videos saved in: {task_dir}")

        return {
            "success": True,
            "task_id": task_id,
            "title": title,
            "catchy_title": metadata.get("catchy_title", title),
            "tags": metadata.get("tags", []),
            "videos": result.get("videos", []),
        }
    except Exception as e:
        logger.error(f"Error processing title '{title}': {e}")
        return {"success": False, "task_id": task_id, "title": title, "error": str(e)}


def main():
    """Main function to process all titles."""
    parser = argparse.ArgumentParser(description="Batch Video Maker")
    parser.add_argument("--file", required=True, help="Path to file containing video titles (one per line)")
    parser.add_argument("--max-titles", type=int, default=None, help="Maximum number of titles to process")
    parser.add_argument("--start-index", type=int, default=0, help="Start processing from this index")

    args = parser.parse_args()

    # Setup logger
    setup_logger()

    # Read titles from file
    titles = read_titles_from_file(args.file)
    if not titles:
        logger.error("No titles found in the file or file could not be read.")
        return

    # Apply max_titles and start_index
    if args.start_index >= len(titles):
        logger.error(f"Start index {args.start_index} is out of range (max: {len(titles)-1})")
        return

    titles = titles[args.start_index:]
    if args.max_titles:
        titles = titles[:args.max_titles]

    logger.info(f"Found {len(titles)} titles to process")

    # Process each title
    results = []
    for i, title in enumerate(titles):
        # 从配置文件创建视频参数
        params = create_video_params(title=title)

        result = process_title(title, i, len(titles), params)
        results.append(result)

        # 确保 storage/batch 目录存在
        batch_dir = utils.storage_dir("batch", create=True)
        batch_results_file = os.path.join(batch_dir, "batch_results.json")

        # 保存进度到 storage/batch 目录
        with open(batch_results_file, "w", encoding="utf-8") as f:
            json.dump(results, f, ensure_ascii=False, indent=2)
        logger.info(f"Progress saved to {batch_results_file}")

        # Small delay to prevent overwhelming the system
        time.sleep(1)

    # Print summary
    successful = sum(1 for r in results if r.get("success", False))
    logger.info(f"Processing completed. {successful}/{len(results)} videos generated successfully.")

    # 显示结果文件位置
    batch_dir = utils.storage_dir("batch", create=True)
    batch_results_file = os.path.join(batch_dir, "batch_results.json")
    logger.info(f"Results saved to {batch_results_file}")


if __name__ == "__main__":
    main()
